## 요구 사항
- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

### `Default`
- `/point` 패키지 (디렉토리) 내에 `PointService` 기본 기능 작성
- `/database` 패키지의 구현체는 수정하지 않고, 이를 활용해 기능을 구현
- 각 기능에 대한 단위 테스트 작성

> 총 4가지 기본 기능 (포인트 조회, 포인트 충전/사용 내역 조회, 충전, 사용) 을 구현합니다.
> 

**[Step 1]**
- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
- 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링
- 동시성 제어에 대한 통합 테스트 작성

**[Step 2]**
- 동시성 제어 방식에 대한 분석 및 보고서 작성

--- 

## Java의 동시성 문제
- 자바는 멀티 스레드를 지원합니다.
- 자바에서 동시성이란 여러 스레드가 하나의 자원에 동시에 접근하는 것이고, 동시성 문제는 해당 과정에서 **동기화 되지 않은 데이터의 결과를 말합니다**

## Java의 동시성 해결과 동기화
멀티 스레드 환경에서의 동시성 문제를 해결하기 위해 Java는 객체에 대해 `thread-safe`할 수 있게 **스레드 간 동기화를 시키는 방법을 사용**합니다.

Java에서는 스레드가 임계영역에 진입하는 경우 Lock이라는 것을 획득하게 되고, 임계영역에서 빠져나올때 Lock을 되돌려줌으로서 두 개 이상의 프로세스나 스레드가 동시에 임계영역에 진입할 수 없도록 하여 동시성을 해결하도록 합니다.

## Lock 이란?
락(lock)은 공유 리소스에 대한 액세스를 조정하고 여러 스레드가 동시에 액세스하지 못하도록 코드의 중요한 부분을 보호하는 데 사용됩니다.

이러한 메커니즘은 한 번에 하나의 스레드만 동기화된 블록 혹은 메서드에 액세스할 수 있도록 하여 데이터 손상과 경합을 방지합니다. Java는 이러한 동기화 달성을 위해 여러 메커니즘을 제공합니다.

## ReentrantLock
동시성 문제를 해결하기 위해 `synchronized`, `LockSupport` 등을 사용할 수 있지만 여기서는  `Lock` 인터페이스와 `ReentrantLock` 이라는 구현체로 임계영역을 다루는 방법을 설명하도록 하겠습니다. 

ReentrantLock은 보다 유연하고 명시적인 잠금 관리 방법을 제공하는 `java.util.concurrent.locks` 패키지의 클래스입니다.

`synchronized` 를 사용하여 동시성 문제를 사용하는 경우 다음과 같은 문제가 발생할 수 있습니다.
1. **무한 대기** : `BLOCKED` 상태 스레드는 락이 풀릴 때 까지 무한 대기한다.
2. **공정성**: 락이 돌아왔을 때 `BLOCKED` 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다. 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다. 

### `Lock` 인터페이스
`Lock` 인터페이스는 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용합니다.
```java
public interface Lock {
   void lock();
   void lockInterruptibly() throws InterruptedException;
   boolean tryLock();
   boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
   void unlock();
   Condition newCondition();
}
```
`Lock` 인터페이스의 대표적인 구현체로 `ReentrantLock` 이 있는데, 이 클래스는 스레드가 “공정하게” 락을 얻을 수 있는 모드를 제공합니다.

Lock 인터페이스에서 제공하는 주요 메서드는 다음과 같습니다
- `void lock()` : 락을 획득. 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기( `WAITING` )합니다. 이 메서드는 인터럽트에 응답하지 않는다.
- `void unlock()` : 락을 해제. 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 됩니다. 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException`이 발생할 수 있습니다.
- `tryLock()` :  획득할 때 타임아웃을 설정할 수 있습니다

### **비공정 모드** (Non-fair mode) 와 공정성(fairness) 모드

`ReentrantLock` 락은 공정성(fairness) 모드와 비공정(non-fair) 모드로 설정할 수 있으며, 이 두 모드는 락을 획득 하는 방식에서 차이가 있습니다. 

```java
ReentrantLock unfairLock = new ReentrantLock(); // 비공정한 동기화 (기본 설정)
ReentrantLock fairLock = new ReentrantLock(true); // 공정한 동기화 설정
```

1. `ReentrantLock`의 기본모드는 비공정 모드입니다.
    - 비공정 모드는 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이없습니다. 락을 풀었을 때, 대기 중인 스레드 중 아무나 락을 획득하게 됩니다.
    - 락을 획득하는 속도는 빨라지지만, 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있습니다.
    - 해당 과정에서 특정 스레드가 계속해서 락을 획득하지 못할 수 있습니다.
2. `ReentrantLock` 의 생성자에 `true`를 전달하게 되면 공정 모드입니다.
    - 공정 모드는 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 합니다.
    - 이는 먼저 대기한 스레드가 먼저 락을 획득하게 되어 스레드 간의 공정성을 보장하게됩니다.
    - `ReentrantLock` 는 내부적으로 대기 중인 스레드를 위한 FIFO(First-In-First-Out) Queue를 유지합니다. 즉, 먼저 대기한 스레드가 나중에 요청한 스레드보다 우선적으로 락을 획득할 수 있도록 합니다.
    - 해당 옵션을 통해 모든 스레드가 공정하게 자원을 사용할 수 있도록 도와줍니다.

## Point-API 에서의 동시성 처리 필요성

- 동일한 유저의 포인트를 여러 스레드가 동시에 변경하려고 할 때 문제가 발생할 수 있습니다.
    - 예를 들어, 유저 A가 동시에 100 포인트를 충전하고, 같은 시점에 다른 스레드에서 50 포인트를 사용하려고 할 경우, 두 작업이 충돌하여 최종 잔액이 잘못 계산될 수 있습니다.
- 포인트 사용 및 충전이 동시에 발생할 때 문제가 발생할 수 있습니다
    - 예를 들어, 사용자가 포인트를 충전한 직후에 사용하려 할 경우, 충전된 포인트가 즉시 사용 가능해야 하며, 이러한 상태를 보장하기 위해 **동기화**가 필요합니다.
- 포인트 사용 및 충전은 일반적으로 비즈니스 규칙에 따라 이루어져야 합니다.
    - 예를 들어, 사용자는 항상 자신의 포인트 잔액보다 많은 포인트를 사용하려 할 수 없습니다.
    - 이러한 규칙을 유지하려면 동기화가 필요하며, 모든 요청이 순차적으로 처리되어야 합니다.

## Point-API에서의 ReentrantLock 사용

위 `Lock` 인터페이스에서도 확인할 수 있듯이 `ReentrantLock`을 사용할 때는 락을 수동으로 획득하고 해제해야 합니다.

```java
@Service
public class PointService {
	
	private final Map<Long, ReentrantLock> locks = new ConcurrentHashMap<>();

	// 포인트 충전 로직
	public UserPoint charge(long id, long amount) {
      
	  // ReentrantLock을 사용하여 유저별 락 생성 및 반환
	  Lock lock = locks.computeIfAbsent(id, k -> new ReentrantLock(true)); // 공정성 설정. 락을 대기한 순서대로 스레드가 락을 획득
	  lock.lock();
	  try{
		   // 포인트 충전 비즈니스 로직 작성 
	  } finally {
	     lock.unlock();
	  }
	}
```

- `lock()` 메소드로 락을 획득하고 `unlock()` 메소드로 해제
    - 이를 통해 특정 코드 블록에 대한 락을 명시적으로 지정할 수 있고, 필요할 때만 락을 해제할 수 있습니다.
- `ReentrantLock` 에 `true`를 전달하면 공정 모드가 활성화됩니다. 이는 락을 요청한 스레드가 대기한 순서에 따라 락을 획득할 수 있도록 보장합니다. 이렇게 함으로써 사용자간의 공정한 접근을 보장할 수 있습니다.

**`ReentrantLock`을** `Map`**에 저장하는 이유는 다음과 같습니다**
- **유저별 락 관리**: 포인트 시스템에서는 각 사용자에 대해 별도의 락을 사용하여 동시성을 제어하고, 사용자별로 충전 및 사용 작업의 순서를 보장할 수 있습니다. `Map`에 사용자 ID를 키로 사용하여 `ReentrantLock` 인스턴스를 저장함으로써, 특정 사용자에 대한 락을 쉽게 찾고 사용할 수 있습니다.
- 맵에 저장된 락을 사용하면 필요할 때 쉽게 락을 해제할 수 있습니다. 각 사용자에 대한 작업이 완료된 후, 해당 락을 해제함으로써 다른 스레드가 해당 사용자에 대한 작업을 수행할 수 있도록 합니다.
- `ConcurrentHashMap`은 내부적으로 다수의 스레드가 동시에 접근하더라도 안전하게 데이터를 읽고 쓸 수 있도록 설계되었습니다. 따라서 높은 동시성을 유지하고 데이터의 무결성을 보증합니다. (**thread-safe**를 보장)
